#include <stdint.h>
#include <stm32f401xe.h>



#define led_on 		GPIOD->ODR |= 1<<13
#define led_off		GPIOD->ODR &= ~(1<<13)
#define led_is_off	(GPIOD->ODR & 1<<13) == 0
//
#define toggle_led 					led_is_off ? led_on : (led_off)
//#define button_is_pressed			(GPIOA->IDR & 1) == 1
//#define waiting_button_is_released 	while (button_is_pressed)



void SystemClock_config();
void GPIO_init();
void Timer_init();
//void UART_init();
//void UART_sendChar(char c);
void delay_ms(int ms);



int main()
{
	SystemClock_config();
	GPIO_init();
	Timer_init();

//	UART_init();
//	led_on;

	while(1)
	{
		toggle_led;
//		toggle_led;
//		UART_sendChar('a');
		delay_ms(500);
	}
}



void SystemClock_config()
{
	RCC->CR |= RCC_CR_HSION;				// enable HSI
	while (!(RCC->CR & RCC_CR_HSIRDY));		// see that HSI is ready or not

	// Power regulator
	PWR->CR |= (1<<15);

	// Flash latency setup
	FLASH->ACR |= FLASH_ACR_DCEN | FLASH_ACR_ICEN | FLASH_ACR_PRFTEN | FLASH_ACR_LATENCY_5WS;

	// Clock configuration register for setting
	RCC->CFGR |= RCC_CFGR_SW_HSI;
	while ( (RCC->CFGR & (1<<2)) || (RCC->CFGR & (1<<3)) );




//#define PLL_M 	4
//	#define PLL_N 	180
//	#define PLL_P 	0  // PLLP = 2
//
//	// 1. ENABLE HSE and wait for the HSE to become Ready
//	RCC->CR |= RCC_CR_HSEON;
//	while (!(RCC->CR & RCC_CR_HSERDY));
//
//	// 2. Set the POWER ENABLE CLOCK and VOLTAGE REGULATOR
//	RCC->APB1ENR |= RCC_APB1ENR_PWREN;
//	PWR->CR |= PWR_CR_VOS;
//
//
//	// 3. Configure the FLASH PREFETCH and the LATENCY Related Settings
//	FLASH->ACR = FLASH_ACR_ICEN | FLASH_ACR_DCEN | FLASH_ACR_PRFTEN | FLASH_ACR_LATENCY_5WS;
//
//	// 4. Configure the PRESCALARS HCLK, PCLK1, PCLK2
//	// AHB PR
//	RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
//
//	// APB1 PR
//	RCC->CFGR |= RCC_CFGR_PPRE1_DIV4;
//
//	// APB2 PR
//	RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;
//
//
//	// 5. Configure the MAIN PLL
//	RCC->PLLCFGR = (PLL_M <<0) | (PLL_N << 6) | (PLL_P <<16) | (RCC_PLLCFGR_PLLSRC_HSE);
//
//	// 6. Enable the PLL and wait for it to become ready
//	RCC->CR |= RCC_CR_PLLON;
//	while (!(RCC->CR & RCC_CR_PLLRDY));
//
//	// 7. Select the Clock Source and wait for it to be set
//	RCC->CFGR |= RCC_CFGR_SW_PLL;
//	while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL);
}



void GPIO_init(void)
{
	RCC->AHB1ENR |= (1<<3);		// IO port D clock enable

	GPIOD->MODER |= (1<<26);	// General purpose output mode
	GPIOD->MODER &= ~(1<<27);

	GPIOD->OTYPER &= ~(1<<13);	// Output push-pull (reset state)




//	RCC->AHB1ENR |= (1<<0);		// IO port A clock enable
//
//	GPIOA->MODER |= (2<<18);	// alternate function for PA9
//
//	GPIOA->OSPEEDR |= (2<<18);	// high speed for PA9
//
//	GPIOA->AFR[1] |= (7<<4);	// bit 9, USART




//	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;  	// Enable GPIOA CLOCK
//
//	GPIOA->MODER |= (2<<4);   				// Alternate Function for Pin PA2
//	GPIOA->MODER |= (2<<6);   				// Alternate Function for Pin PA3
//
//	GPIOA->OTYPER &= ~(1<<2);				// Output push-pull (reset state) for PA2
//
//	GPIOA->OSPEEDR |= (2<<4);				// high speed for PA2

//	GPIOA->AFR[0] |= (7<<8);   					// AF7 Alternate function for USART2 at Pin PA2
//		GPIOA->AFR[0]  |= (7<<12);   				// AF7 Alternate function for USART2 at Pin PA3
}



void Timer_init()
{
	RCC->APB2ENR |= RCC_APB2ENR_TIM1EN; 		// TIM1 clock enable

	TIM1->PSC |= 15999;
	// F_timer = F_system / (PSC + 1) = 16,000,000 / 16,000 = 1KHz
	// => T_timer = 1ms

	TIM1->ARR = 65535;							// Auto-reload value

	TIM1->CR1 |= TIM_CR1_CEN;					// Counter enable
	TIM1->CR1 &= ~(1<<4);						// Counter used as up counter

	//	while (!(TIM1->SR & (1<<0)));			// reset
}



//void UART_init()
//{
//	RCC->APB2ENR |= (1<<4); 		// USART1 clock enable
//
//	USART1->CR1 = 0x00;   			// Clear ALL
//
//	USART1->CR1 |= (1<<3); 			// transmit enable
//	USART1->CR1 |= (1<<13);			// USART enable
//
//	USART1->CR1 &= ~(1<<12);		// 1 Start bit, 8 Data bits, n Stop bit
//
//	USART1->CR1 &= ~(1<<10);					// no parity
//
//	USART1->CR2 &= ~(2<<12);					// 1 stop bit
//
//	/*
//	 * USART_DIV = Fck / (baud * 16)
//	 * 			 = 16,000,000 / (9600 * 16)
//	 * 			 = 104.16667
//	 *
//	 * mantissa = 104
//	 * fraction = 0.16667 * 16 = 3
//	 * */
//	USART1->BRR |= (104<<4) | (3<<0);
//
//
//
//
//
//	/* USART2 */
////	RCC->APB1ENR |= RCC_APB1RSTR_USART2RST;		// Enable USART2 clock
////
////
////
//////	USART2->CR1 = 0x00;   						// Clear ALL
////
////	USART2->CR1 |= (1<<3);  					// Enable Transmitter
////	USART2->CR1 |= (1<<2); 						// Enable the Receiver
////
////	USART2->CR1 &= ~(1<<12);					// 1 Start bit, 8 Data bits, n Stop bit
////
////	USART2->CR1 &= ~(1<<10);					// no parity
////
////	USART2->CR1 |= (1<<13);   					// UE = 1... Enable USART
////
////	USART2->CR2 &= ~(2<<12);					// 1 stop bit
////
////
////	USART2->BRR = (273<<4) | (7<<0); 			// Baud rate of 9600, PCLK1 at 42MHz
//}



//void UART_sendChar(char c)
//{
//	while (!(USART1->SR & (1<<7)));
//	USART1->DR = c;
//
//	while ((USART1->SR & (1<<6)) == 0);
//
//
//
////	while (!(USART2->SR & (1<<7)));
////
////	USART2->DR = c;   					// Load the Data
////	while (!(USART2->SR & (1<<6)));  	// Wait for TC to SET.. This indicates that the data has been transmitted
//}



void delay_ms(int ms)
{
	TIM1->CNT = 0;
	while (TIM1->CNT < ms);
}


