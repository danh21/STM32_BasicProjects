/*
 * ADC.h
 *
 *  Created on: Mar 11, 2024
 *      Author: danh21
 */

#ifndef ADC_H_
#define ADC_H_



#define max_ADC1 4095;



void ADC1_Init()
{
	RCC->APB2ENR |= (1<<8);		// enable ADC1 clock

	ADC->CCR &= ~(3<<16);  		 // PCLK2 divided by 2

//	ADC1->CR1 |= (1<<8);		// enable SCAN mode because using more ADC channels
	ADC1->CR1 |= (1<<24);		// resolution 10-bit
//	ADC1->CR1 |= (1<<5);		// Enable interrupt mode for EOC

	ADC1->CR2 |= (1<<0);		// adc enable respectively
	ADC1->CR2 |= (1<<1);		// continuous conversion mode
	ADC1->CR2 |= (1<<10);		// EOC after each conversion
	ADC1->CR2 &= ~(1<<11);		// data alignment right

	ADC1->SMPR2 &= ~(7<<3);		// 3 clock cycle polling, 1th channel
//	ADC1->SMPR2 |= (1<<3);



	//ADC->CSR:going to read bits (5->ADC1overrun), 4->ADC1RegularStartsuccess
	//ADC->CSR:read bit (1->End of conversion for ADC1)

//	ADC1->CR2 |= (1<<30);		// start conversion of regular channels only with ADON=1


//	ADC->CCR |= (1<<23);		// Temperature sensor enable and V_refint channel enabled

}



void ADC1_Start_Polling()
{
//	ADC1->CR2 &= ~(1<<10);		// The EOC bit is set at the end of each sequence of regular conversions. Overrun detection is enabled only if DMA=1
//	ADC1->SR = 0;				// clear status
	ADC1->CR2 |= (1<<30);		// start regular conversion
	while(!(ADC1->SR & (1<<4)));// wait until conversion starts
}



uint32_t ADC1_Read()
{
	uint32_t ADC_data;
	ADC_data = ADC1->DR;
	return ADC_data;
}



void ADC1_End()
{
	ADC1->CR2 |= (1<<10); 		//bit is set at the end of each regular conversion.
}



#endif /* ADC_H_ */
